import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Callable, Union
from scipy.optimize import minimize

from fernholz_spt.core.market_model import MarketModel

class FunctionallyGeneratedPortfolio:
    """
    Implementation of functionally generated portfolios as described by Fernholz.
    
    Fernholz showed that certain portfolios can be generated by applying a function
    to the market weights. These functionally generated portfolios have special
    properties that make them useful for long-term investment strategies.
    """
    
    def __init__(self, market_model: MarketModel):
        """
        Initialize with a market model.
        
        Args:
            market_model: Initialized MarketModel instance
        """
        self.market_model = market_model
        
    def equal_weighted(self) -> pd.DataFrame:
        """
        Generate equal-weighted portfolio.
        
        The equal-weighted portfolio assigns equal weight to each stock:
        
        π_i = 1/n for all i
        
        Returns:
            DataFrame of portfolio weights
        """
        weights = pd.DataFrame(
            1.0 / self.market_model.n_stocks, 
            index=self.market_model.market_weights.index,
            columns=self.market_model.stock_names
        )
        return weights
    
    def market_weighted(self) -> pd.DataFrame:
        """
        Generate market-weighted portfolio (i.e., market portfolio).
        
        The market portfolio weights are equal to the market weights:
        
        π_i = μ_i for all i
        
        Returns:
            DataFrame of portfolio weights
        """
        return self.market_model.market_weights.copy()
    
    def diversity_weighted(self, p: float = 0.5) -> pd.DataFrame:
        """
        Generate diversity-weighted portfolio with parameter p.
        
        The diversity-weighted portfolio has weights:
        
        π_i = (μ_i)^p / Σ_j (μ_j)^p
        
        Args:
            p: Diversity parameter (0 < p < 1)
            
        Returns:
            DataFrame of portfolio weights
        """
        if p <= 0 or p >= 1:
            raise ValueError(f"p must be in (0, 1), got {p}")
            
        weights = pd.DataFrame(index=self.market_model.market_weights.index, 
                              columns=self.market_model.stock_names)
        
        for date in weights.index:
            market_weights = self.market_model.market_weights.loc[date].values
            
            # Apply diversity transformation
            w = np.power(market_weights, p)
            
            # Normalize
            weights.loc[date] = w / np.sum(w)
            
        return weights
    
    def entropy_weighted(self) -> pd.DataFrame:
        """
        Generate entropy-weighted portfolio.
        
        The entropy-weighted portfolio has weights:
        
        π_i = -μ_i * log(μ_i) / Σ_j -μ_j * log(μ_j)
        
        Returns:
            DataFrame of portfolio weights
        """
        weights = pd.DataFrame(index=self.market_model.market_weights.index, 
                              columns=self.market_model.stock_names)
        
        for date in weights.index:
            market_weights = self.market_model.market_weights.loc[date].values
            
            # Calculate entropy weights, avoiding log(0)
            w = np.zeros_like(market_weights)
            positive_idx = market_weights > 0
            w[positive_idx] = -market_weights[positive_idx] * np.log(market_weights[positive_idx])
            
            # Normalize
            if np.sum(w) > 0:
                weights.loc[date] = w / np.sum(w)
            else:
                # Fallback to equal weights if all weights are zero
                weights.loc[date] = 1.0 / self.market_model.n_stocks
            
        return weights
    
    def volatility_weighted(self, window: int = 252) -> pd.DataFrame:
        """
        Generate inverse-volatility weighted portfolio.
        
        The inverse-volatility weighted portfolio has weights:
        
        π_i = (1/σ_i) / Σ_j (1/σ_j)
        
        where σ_i is the volatility of stock i.
        
        Args:
            window: Rolling window for volatility calculation
            
        Returns:
            DataFrame of portfolio weights
        """
        weights = pd.DataFrame(index=self.market_model.market_weights.index, 
                              columns=self.market_model.stock_names)
        
        # Calculate rolling volatility
        rolling_vol = self.market_model.log_returns.rolling(window=window).std().dropna()
        
        for date in weights.index:
            if date in rolling_vol.index:
                vol = rolling_vol.loc[date].values
                
                # Replace zeros and NaNs with high values
                vol[vol == 0] = np.nanmax(vol) * 10
                vol = np.nan_to_num(vol, nan=np.nanmax(vol) * 10)
                
                # Calculate inverse volatility weights
                inv_vol = 1.0 / vol
                weights.loc[date] = inv_vol / np.sum(inv_vol)
            else:
                # Fallback to equal weights
                weights.loc[date] = 1.0 / self.market_model.n_stocks
            
        return weights
    
    def custom_generated(self, 
                         generating_function: Callable[[np.ndarray], float],
                         gradient_function: Optional[Callable[[np.ndarray], np.ndarray]] = None) -> pd.DataFrame:
        """
        Generate portfolio using a custom generating function.
        
        According to Fernholz's theory, a portfolio π can be generated from a
        function G using:
        
        π_i = μ_i * (1 + D_i G(μ))
        
        where D_i is the partial derivative with respect to μ_i.
        
        Args:
            generating_function: Function G that maps market weights to a real value
            gradient_function: Gradient of G. If None, numerical differentiation is used
            
        Returns:
            DataFrame of portfolio weights
        """
        weights = pd.DataFrame(index=self.market_model.market_weights.index, 
                              columns=self.market_model.stock_names)
        
        # Function to numerically approximate the gradient if not provided
        def numerical_gradient(func, x, eps=1e-6):
            grad = np.zeros_like(x)
            for i in range(len(x)):
                x_plus = x.copy()
                x_plus[i] += eps
                x_minus = x.copy()
                x_minus[i] -= eps
                grad[i] = (func(x_plus) - func(x_minus)) / (2 * eps)
            return grad
        
        for date in weights.index:
            market_weights = self.market_model.market_weights.loc[date].values
            
            # Calculate gradient
            if gradient_function is not None:
                grad = gradient_function(market_weights)
            else:
                grad = numerical_gradient(generating_function, market_weights)
            
            # Calculate portfolio weights using Fernholz's formula
            w = market_weights * (1 + grad)
            
            # Normalize to ensure weights sum to 1
            weights.loc[date] = w / np.sum(w)
            
        return weights
    
    def calculate_drift_process(self, portfolio_weights: pd.DataFrame) -> pd.Series:
        """
        Calculate the drift process of a portfolio relative to the market.
        
        The drift process represents the excess growth rate of the portfolio
        compared to the market portfolio. It is a key quantity in SPT.
        
        Args:
            portfolio_weights: DataFrame of portfolio weights
            
        Returns:
            Series of drift process values over time
        """
        drift = pd.Series(index=portfolio_weights.index)
        
        for date in portfolio_weights.index:
            # Skip dates without covariance matrix
            if self.market_model.cov_matrices is None or date not in self.market_model.cov_matrices:
                drift[date] = np.nan
                continue
                
            # Get weights and covariance
            pi = portfolio_weights.loc[date].values
            mu = self.market_model.market_weights.loc[date].values
            cov_matrix = self.market_model.cov_matrices[date]
            
            # Calculate relative weights
            relative_weights = np.zeros_like(pi)
            nonzero_idx = mu > 0
            relative_weights[nonzero_idx] = pi[nonzero_idx] / mu[nonzero_idx]
            
            # Calculate drift using Fernholz's formula (gamma_t)
            # gamma_t = 0.5 * Σ_i σ_ii * (π_i/μ_i - 1)^2
            drift[date] = 0.5 * np.sum(np.diag(cov_matrix) * (relative_weights - 1)**2)
            
        return drift
